<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trading Visualization</title>
    <!--<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>-->
    <script src="/static/js/lightweight-charts@4.2.3/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/modules/accessibility.js"></script>
    <style>
    @media (prefers-color-scheme: dark) {
        #candlestick-chart, #bands-chart, #trade-chart {
            width: 100%;
            height: 400px;

        }
        #orderbook {
            width: 100%;
            height: 500px;
            overflow: auto;
        }
        .row {
          display: flex;
        }

        .column {
          flex: 50%;
        }

        body {
            background-color: black;
            color: white;
        }

        #orderbookbids {
            color: #18a856;
            font-family: sans-serif;
        }

        #orderbookasks {
            color: #a86e18;
            font-family: sans-serif;
        }

        .title {
            font-family: Courier, monospace;
        }
    }
    </style>
</head>
<body>

    <!-- Loading progress bar (hidden by default) -->
    <div id="loading-container" class="loading-container">
        <div class="loading-content">
            <h3>Loading Trade Data Into Server Memory</h3>
            <div class="loading-status-container">
                <div class="loading-progress-container">
                    <div id="loading-progress-bar" class="loading-progress-bar"></div>
                </div>
                <div id="loading-percentage" class="loading-percentage">0%</div>
            </div>
            <div id="loading-message" class="loading-message">Preparing to load...</div>
            <div id="loading-details" class="loading-details">
                <div id="loading-mb-info">Data loaded: 0 MB</div>
                <div id="loading-row-info">Rows: 0</div>
            </div>
        </div>
    </div>
    
<div id="replay-controls" style="padding: 10px; background-color: #333; color: white; margin-bottom: 10px;">
    <h3>Trade Log Replay</h3>
    <div style="display: flex; align-items: center;">
        <button id="play-btn" class="control-btn">Play</button>
        <button id="pause-btn" class="control-btn">Pause</button>
        <button id="stop-btn" class="control-btn">Stop</button>
        <div style="margin-left: 20px;">
            <label for="speed-slider">Speed: <span id="speed-value">1x</span></label>
            <input type="range" id="speed-slider" min="1" max="10000" step="1" value="1">
        </div>
        <div style="margin-left: 20px; flex-grow: 1;">
            <label for="position-slider">Position: <span id="position-value">0/0</span></label>
            <input type="range" id="position-slider" min="0" max="100" value="0" style="width: 100%;">
        </div>
        <div style="margin-left: 20px;">
            <span id="filename">No file loaded</span>
        </div>
    </div>
</div>

<style>
    .control-btn {
        padding: 5px 15px;
        margin-right: 5px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    .control-btn:hover {
        background-color: #45a049;
    }
    /* Turbo and Max Speed buttons have been removed */
    .loading-container {
        display: none;
        justify-content: center;
        align-items: center;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 10000;
    }
    .loading-content {
        text-align: center;
        padding: 20px;
        background-color: #333;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        max-width: 500px;
        width: 90%;
    }
    .loading-status-container {
        margin-top: 20px;
    }
    .loading-progress-container {
        width: 100%;
        height: 20px;
        background-color: #f0f0f0;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    .loading-progress-bar {
        width: 0%;
        height: 100%;
        background-color: #4CAF50;
        transition: width 0.3s;
    }
    .loading-percentage {
        font-weight: bold;
        margin-top: 10px;
    }
    .loading-message {
        font-weight: bold;
        margin-top: 20px;
    }
    .loading-details {
        margin-top: 20px;
    }
    #loading-mb-info, #loading-row-info {
        display: none;
    }
</style>
    <div class="row">
        <div class="column">
            <h2 class="title">Depth of Market Chart</h2>
            <div id="dom-container" style="height: 400px; width: 1000px; margin: 1rem 0;"></div>
        </div>
        <div class="column">
            <h2 class="title">Order Book</h2>
            <div id="orderbook"></div>
        </div>
    </div>
    <div class="row">
        <div class="column">
            <h2 class="title">Candlestick Chart</h2>
            <div id="candlestick-chart"></div>
            <div id="candlestick-legend" style="
                position: absolute;
                top: 860px;
                left: 10px;
                z-index: 1;
                font-size: 24px;
                font-family: sans-serif;
                line-height: 28px;
                font-weight: 300;
                background: rgba(73, 73, 74, 0.8); /* Add transparency */
                padding: 5px;
                border-radius: 5px;
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            ">
                <span id="security-id">-</span><br/>
                <strong>Open:</strong> <span id="open-value">-</span><br/>
                <strong>High:</strong> <span id="high-value">-</span><br/>
                <strong>Low:</strong> <span id="low-value">-</span><br/>
                <strong>Close:</strong> <span id="close-value">-</span>
            </div>
        </div>
        <div class="column">
            <h2 class="title">Volume of Trades Chart</h2>
            <div id="trade-chart"></div>
        </div>
    </div>


    <h2 class="title">Moving Averages (Bands)</h2>
    <div id="bands-chart"></div>
    <div id="bands-legend" style="
        position: absolute;
        top: 1320px;
        left: 10px;
        z-index: 1;
        font-size: 24px;
        font-family: sans-serif;
        line-height: 28px;
        font-weight: 300;
        background: rgba(73, 73, 74, 0.8); /* Add transparency */
        padding: 5px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    ">
        <strong>Time:</strong> <span id="band-time">-</span><br/>
        <strong>SMA:</strong> <span id="sma-value">-</span>
    </div>

    <div id="connection-status" style="position: absolute; top: 10px; right: 10px; font-size: 18px;"></div>

    <script>
        const socketOptions = {
            reconnection: true,
            reconnectionAttempts: 10,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            timeout: 20000,
            autoConnect: true
        };
        
        const socket = io(socketOptions);
        
        // Socket connection event handlers
        socket.on('connect', function() {
            console.log('Connected to server');
            document.getElementById('connection-status').textContent = 'Connected';
            document.getElementById('connection-status').style.color = 'green';
        });
        
        socket.on('disconnect', function() {
            console.log('Disconnected from server');
            document.getElementById('connection-status').textContent = 'Disconnected';
            document.getElementById('connection-status').style.color = 'red';
        });
        
        socket.on('connect_error', function(error) {
            console.log('Connection error:', error);
            document.getElementById('connection-status').textContent = 'Connection Error';
            document.getElementById('connection-status').style.color = 'red';
        });

        var security_id = "";

        // Define variables for DOM elements
        const securityId = document.getElementById('security-id');

        // Trade chart
        const tradeChart = LightweightCharts.createChart(document.getElementById('trade-chart'), {
            width: 800,
            height: 400,
            timeScale: {
                timeVisible: true,
                secondsVisible: true,
            },
            layout: { textColor: 'white', background: { type: 'solid', color: 'black' } }
        });
        const tradeSeries = tradeChart.addHistogramSeries({
            color: '#26a69a',
            priceFormat: {
                type: 'volume',
            },
            priceScaleId: 'volume',
            scaleMargins: {
                top: 0.8,
                bottom: 0,
            }
        });

        // Listen for aggregated trades and update the chart
        const aggregatedTradeData = [];
        let volumeChartUpdatePending = false;
        let lastVolumeUpdateTime = 0;

        // Function to update the volume chart - ALWAYS update immediately
        function updateVolumeChart() {
            // Sort the data by time to ensure chart updates correctly
            aggregatedTradeData.sort((a, b) => a.time - b.time);
            
            // Always update the chart immediately
            tradeSeries.setData(aggregatedTradeData);
            volumeChartUpdatePending = false;
        }

        // Add debugging to track aggregated trade updates
        let lastTradeTime = 0;
        let tradeCounter = 0;
        let highSpeedMode = false;
        
        socket.on('aggregated_trade', (aggregatedTrade) => {
            // Count trades for debugging
            tradeCounter++;
            const now = Date.now();
            
            // Log every 100th trade in high speed mode
            if (tradeCounter % 100 === 0) {
                console.log(`Received ${tradeCounter} trades, last update: ${now - lastTradeTime}ms ago`);
                lastTradeTime = now;
            }
            
            // Validate data
            if (!aggregatedTrade.time || !aggregatedTrade.total_volume) {
                console.warn('Invalid trade data:', aggregatedTrade);
                return;
            }

            // Find existing entry for the same time
            const existingIndex = aggregatedTradeData.findIndex((data) => data.time === aggregatedTrade.time);

            if (existingIndex !== -1) {
                // Update existing entry
                aggregatedTradeData[existingIndex].value += aggregatedTrade.total_volume;
            } else {
                // Add new entry
                aggregatedTradeData.push({
                    time: aggregatedTrade.time,
                    value: aggregatedTrade.total_volume,
                });
            }
            
            // Always update the chart immediately - no throttling
            // This ensures the volume chart continues to update at all speeds
            updateVolumeChart();
        });

        // Candlestick chart
        const candlestickChart = LightweightCharts.createChart(document.getElementById('candlestick-chart'), {
            width: 800,
            height: 400,
            timeScale: {
                timeVisible: true,
                secondsVisible: true, // Show seconds if timestamps have small intervals
            },
            layout: { textColor: 'white', background: { type: 'solid', color: 'black' } }
        });
        const candlestickSeries = candlestickChart.addCandlestickSeries();

        // Legend for candlestick chart
        const openValue = document.getElementById('open-value');
        const highValue = document.getElementById('high-value');
        const lowValue = document.getElementById('low-value');
        const closeValue = document.getElementById('close-value');

        securityId.textContent = security_id;

        candlestickChart.subscribeCrosshairMove((param) => {
            //console.log('Crosshair param:', param); // Debug log
            if (param && param.time && param.seriesData) {
                // Retrieve the data for candlestickSeries from seriesData
                const data = param.seriesData.get(candlestickSeries);

                if (data) {

                    openValue.textContent = data.open.toFixed(2); // Display the Open price
                    highValue.textContent = data.high.toFixed(2); // Display the High price
                    lowValue.textContent = data.low.toFixed(2);   // Display the Low price
                    closeValue.textContent = data.close.toFixed(2); // Display the Close price
                    return;
                }
            }

            // Reset legend when no valid data is found
            securityId.textContent = security_id;
            openValue.textContent = '-';
            highValue.textContent = '-';
            lowValue.textContent = '-';
            closeValue.textContent = '-';
        });

        // Function to clear all charts
        function clearAllCharts() {
            console.log("Clearing all charts");
            // Clear candlestick chart
            if (typeof candlestickSeries !== 'undefined') {
                candlestickSeries.setData([]);
                // Clear markers
                candlestickSeries.setMarkers([]);
            }
            
            // Clear price series
            if (typeof priceSeries !== 'undefined') {
                priceSeries.setData([]);
            }
            
            // Clear SMA series
            if (typeof smaSeries !== 'undefined' && Array.isArray(smaSeries)) {
                smaSeries.forEach(series => {
                    if (series && typeof series.setData === 'function') {
                        series.setData([]);
                    }
                });
            }
            
            // Clear volume chart
            if (typeof volumeSeries !== 'undefined') {
                volumeSeries.setData([]);
            }
            
            // Clear trade volume chart (histogram)
            if (typeof tradeSeries !== 'undefined') {
                tradeSeries.setData([]);
                // Also clear the data array
                if (typeof aggregatedTradeData !== 'undefined' && Array.isArray(aggregatedTradeData)) {
                    aggregatedTradeData.length = 0; // Clear the array
                }
            }
            
            // Clear DOM chart (Depth of Market)
            if (typeof domChart !== 'undefined') {
                // Clear both bid and ask series
                if (domChart.series && domChart.series.length >= 2) {
                    domChart.series[0].setData([], true); // Clear bids
                    domChart.series[1].setData([], true); // Clear asks
                }
            }
            
            // Clear orderbook display
            const orderbookBids = document.getElementById('orderbookbids');
            const orderbookAsks = document.getElementById('orderbookasks');
            if (orderbookBids) orderbookBids.innerHTML = '';
            if (orderbookAsks) orderbookAsks.innerHTML = '';
            
            // Also clear the HTML orderbook if it exists
            const orderbookDiv = document.getElementById('orderbook');
            if (orderbookDiv) {
                orderbookDiv.innerHTML = `
                    <h3>Bids</h3>
                    <ul id="orderbookbids"></ul>
                    <h3>Asks</h3>
                    <ul id="orderbookasks"></ul>
                `;
            }
        }
        
        // Initial candlestick data load and chart setup
        socket.on('candlestick', function(data) {
            console.log("Received initial candlestick data, length:", data ? data.length : 0);
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.log("Empty candlestick data received - clearing chart");
                // Clear all charts when receiving empty data
                clearAllCharts();
                return;
            }
            
            try {
                // Format the data correctly for the chart
                const formattedData = [];
                
                for (let i = 0; i < data.length; i++) {
                    const candle = data[i];
                    
                    // Ensure all required fields have valid numeric values
                    const time = typeof candle.time === 'number' ? candle.time : parseInt(candle.time || 0);
                    const open = parseFloat(candle.open || 0);
                    const high = parseFloat(candle.high || 0);
                    const low = parseFloat(candle.low || 0);
                    const close = parseFloat(candle.close || 0);
                    
                    // Skip invalid candles (e.g., with time=0 or NaN values)
                    if (time <= 0 || isNaN(time) || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                        console.warn('Skipping invalid candle at index', i, ':', candle);
                        continue;
                    }
                    
                    // Ensure high is never less than low (which can cause chart errors)
                    const validHigh = Math.max(high, low, open, close);
                    const validLow = Math.min(low, high, open, close);
                    
                    formattedData.push({
                        time: time,
                        open: open,
                        high: validHigh,
                        low: validLow,
                        close: close
                    });
                }
                
                // Skip if we don't have valid data after formatting
                if (formattedData.length === 0) {
                    console.warn("No valid candlestick data after formatting");
                    // Initialize with empty data to avoid errors
                    candlestickSeries.setData([]);
                    return;
                }
                
                // Sort by time to ensure proper order
                formattedData.sort((a, b) => a.time - b.time);
                
                console.log("Setting candlestick data, count:", formattedData.length);
                console.log("First candle:", formattedData[0]);
                console.log("Last candle:", formattedData[formattedData.length - 1]);
                
                try {
                    candlestickSeries.setData(formattedData);
                } catch (e) {
                    console.error("Error setting candlestick data:", e);
                    // Try with a simpler dataset as fallback
                    const fallbackData = [
                        { time: Math.floor(Date.now() / 1000), open: 10, high: 11, low: 9, close: 10.5 }
                    ];
                    console.log("Trying fallback data:", fallbackData);
                    candlestickSeries.setData(fallbackData);
                }
                
                // Also update the price line chart
                const priceData = formattedData.map(candle => ({
                    time: candle.time,
                    value: candle.close
                }));
                
                //console.log("Setting price data:", priceData);
                priceSeries.setData(priceData);
                
                // Update the security ID display
                if (data[0].security_id) {
                    securityId.textContent = data[0].security_id;
                }
            } catch (e) {
                console.error("Error setting chart data:", e);
            }
        });

        // Handle candlestick updates - optimized for performance
        socket.on('candlestick_update', function(data) {
            try {
                console.log("Received candlestick update, candles count:", data.candles ? data.candles.length : 0);
                
                // Check if we received empty data (chart clearing signal)
                if (!data.candles || !Array.isArray(data.candles) || data.candles.length === 0) {
                    console.log("Empty candlestick update received - clearing chart");
                    clearAllCharts();
                    return;
                }
                
                // Format data properly regardless of update type
                const formattedCandles = [];
                
                for (let i = 0; i < (data.candles || []).length; i++) {
                    const candle = data.candles[i];
                    
                    // Ensure all required fields have valid numeric values
                    const time = typeof candle.time === 'number' ? candle.time : parseInt(candle.time || 0);
                    const open = parseFloat(candle.open || 0);
                    const high = parseFloat(candle.high || 0);
                    const low = parseFloat(candle.low || 0);
                    const close = parseFloat(candle.close || 0);
                    
                    // Skip invalid candles with more comprehensive validation
                    if (time <= 0 || isNaN(time) || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                        console.warn('Skipping invalid candle in update at index', i, ':', candle);
                        continue;
                    }
                    
                    // Ensure high is never less than low (which can cause chart errors)
                    const validHigh = Math.max(high, low, open, close);
                    const validLow = Math.min(low, high, open, close);
                    
                    formattedCandles.push({
                        time: time,
                        open: open,
                        high: validHigh,
                        low: validLow,
                        close: close
                    });
                }
                
                // Sort by time to ensure proper order
                formattedCandles.sort((a, b) => a.time - b.time);
                
                // Always use setData to avoid timeline conflicts
                if (formattedCandles.length > 0) {
                    console.log("Setting candlestick data, count:", formattedCandles.length);
                    console.log("First candle:", formattedCandles[0]);
                    console.log("Last candle:", formattedCandles[formattedCandles.length - 1]);
                    
                    try {
                        // Use update method for individual candles if possible
                        if (formattedCandles.length === 1) {
                            candlestickSeries.update(formattedCandles[0]);
                        } else {
                            candlestickSeries.setData(formattedCandles);
                        }
                    } catch (chartError) {
                        console.error("Error setting candlestick data:", chartError);
                        console.log("Problematic data:", JSON.stringify(formattedCandles));
                        
                        // Try with a simpler dataset as fallback
                        try {
                            const fallbackData = [
                                { time: Math.floor(Date.now() / 1000), open: 10, high: 11, low: 9, close: 10.5 }
                            ];
                            console.log("Trying fallback data:", fallbackData);
                            candlestickSeries.setData(fallbackData);
                        } catch (fallbackError) {
                            console.error("Even fallback data failed:", fallbackError);
                        }
                    }
                    
                    // Update security ID if available
                    if (data.candles[0] && data.candles[0].security_id) {
                        securityId.textContent = data.candles[0].security_id;
                    }
                    
                    // Also update the price series with the same data
                    try {
                        // Convert candlestick data to price line data
                        const priceData = formattedCandles.map(candle => ({
                            time: candle.time,
                            value: candle.close
                        }));
                        
                        // Always use setData to avoid timeline conflicts
                        //console.log("Setting price data:", priceData);
                        priceSeries.setData(priceData);
                    } catch (priceError) {
                        console.error("Error updating price series:", priceError);
                    }
                }
            } catch (e) {
                console.error("Error updating candlestick:", e);
            }
        });

        // Order book
        socket.on('orderbook', (data) => {
            const orderbookDiv = document.getElementById('orderbook');
            if (!orderbookDiv) return;
            orderbookDiv.innerHTML = `
                <h3>Bids</h3>
                <ul id="orderbookbids">${data.bids.map(order => `<li>${order.price} @ ${order.size}</li>`).join('')}</ul>
                <h3>Asks</h3>
                <ul id="orderbookasks">${data.asks.map(order => `<li>${order.price} @ ${order.size}</li>`).join('')}</ul>
            `;
        });

        // Listen for trade updates - handles all trade data updates
        socket.on('trade', function(data) {
            // Validate we have meaningful data before processing
            if (!data) {
                console.warn("Received null or undefined trade data");
                return;
            }
            
            try {
                // Safely parse numeric values with defaults
                const price = data.price ? parseFloat(data.price) : 0;
                const size = data.size ? parseFloat(data.size) : 0;
                const total = price * size;
                
                // Make sure all DOM element references are defined
                // Trade info display elements
                const priceValue = document.getElementById('price-value') || document.createElement('span');
                const sizeValue = document.getElementById('size-value') || document.createElement('span');
                const totalValue = document.getElementById('total-value') || document.createElement('span');
                const sideValue = document.getElementById('side-value') || document.createElement('span');
                const timeValue = document.getElementById('time-value') || document.createElement('span');
                const securityId = document.getElementById('security-id') || document.createElement('span');
                
                // Trade statistics elements
                const lastPriceValue = document.getElementById('last-price') || document.createElement('span');
                const highValue = document.getElementById('high-value') || document.createElement('span');
                const lowValue = document.getElementById('low-value') || document.createElement('span');
                const volumeValue = document.getElementById('volume-value') || document.createElement('span');
                const openValue = document.getElementById('open-value') || document.createElement('span');
                const closeValue = document.getElementById('close-value') || document.createElement('span');
                
                // Update price display if we have valid price data
                if (!isNaN(price) && price > 0) {
                    priceValue.textContent = price.toFixed(2);
                    
                    // Also update the last price display
                    lastPriceValue.textContent = price.toFixed(2);
                }
                
                // Update size and total with safety checks
                if (!isNaN(size)) {
                    sizeValue.textContent = size.toFixed(2);
                    
                    if (!isNaN(total)) {
                        totalValue.textContent = total.toFixed(2);
                    }
                }
                
                // Update other trade info
                if (data.side) {
                    sideValue.textContent = data.side;
                    sideValue.className = data.side.toLowerCase() === 'buy' ? 'buy-side' : 'sell-side';
                }
                
                // Update security ID from trade
                if (data.security_id) {
                    securityId.textContent = data.security_id;
                }
                
                // Update trade timestamp display
                if (data.time) {
                    try {
                        const tradeTime = new Date(data.time);
                        if (!isNaN(tradeTime.getTime())) { // Valid date check
                            timeValue.textContent = tradeTime.toLocaleTimeString();
                        } else {
                            timeValue.textContent = new Date().toLocaleTimeString();
                        }
                    } catch (timeError) {
                        console.error("Error parsing trade time:", timeError);
                        timeValue.textContent = new Date().toLocaleTimeString();
                    }
                } else {
                    timeValue.textContent = new Date().toLocaleTimeString();
                }
            } catch (e) {
                console.error("Error processing trade data:", e, data);
            }
        });

        // Maintain a local array of markers
        const markers = [];

        // Listen for new markers from the server
        socket.on('market_maker_marker', (marker) => {
            //console.log('Received marker:', marker);

            // Add the new marker to the local array
            markers.push(marker);

            // Update the markers on the chart
            candlestickSeries.setMarkers(markers);
        });

        // Bands chart (SMA)
        const bandsChart = LightweightCharts.createChart(document.getElementById('bands-chart'), {
            width: 800,
            height: 400,
            timeScale: {
                timeVisible: true,
                secondsVisible: true,
            },
            layout: { textColor: 'white', background: { type: 'solid', color: 'black' } },
            grid: {
                vertLines: { color: 'rgba(70, 70, 70, 0.5)' },
                horzLines: { color: 'rgba(70, 70, 70, 0.5)' }
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
                vertLine: {
                    width: 8,
                    color: 'rgba(224, 227, 235, 0.1)',
                    style: 0,
                },
                horzLine: {
                    width: 8,
                    color: 'rgba(224, 227, 235, 0.1)',
                    style: 0,
                },
            },
        });

        // Price series for the bands chart
        const priceSeries = bandsChart.addLineSeries({
            color: 'white',
            lineWidth: 2,
            priceFormat: {
                type: 'price',
                precision: 2,
                minMove: 0.01,
            },
            title: 'Price',
        });

        // Add SMA series with different colors
        const smaColors = ['#FF6347', '#4169E1', '#32CD32'];
        const smaSeries = [];
        
        // Create SMA series with different periods
        [5, 10, 20].forEach((period, index) => {
            const series = bandsChart.addLineSeries({
                color: smaColors[index],
                lineWidth: 2,
                priceFormat: {
                    type: 'price',
                    precision: 2,
                    minMove: 0.01,
                },
                title: `SMA ${period}`,
            });
            smaSeries.push(series);
        });

        // Legend for bands chart
        const bandTime = document.getElementById('band-time');
        const smaValue = document.getElementById('sma-value');

        bandsChart.subscribeCrosshairMove((param) => {
            //console.log('Crosshair param:', param); // Debug log
             if (param && param.time && param.seriesData) {
                // Retrieve the data for bandsSeries from seriesData
                const data = param.seriesData.get(bandsChart.series()[0]);

                if (data && data.value !== undefined) {
                    bandTime.textContent = new Date(param.time * 1000).toISOString(); // Convert timestamp to readable format
                    smaValue.textContent = data.value.toFixed(2); // Display the SMA value
                    return;
                }
            }

            // Reset legend when there's no valid data
            bandTime.textContent = '-';
            smaValue.textContent = '-';
        });

        // Listen for moving average updates
        socket.on('moving_averages', function(data) {
            console.log('Received moving averages, length:', data ? data.length : 0);
            
            // Check if we received empty data (chart clearing signal)
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.log("Empty moving averages data received - clearing charts");
                // Clear all SMA series
                smaSeries.forEach((series, index) => {
                    try {
                        series.setData([]);
                    } catch (e) {
                        console.error(`Error clearing SMA ${index} data:`, e);
                    }
                });
                return;
            }
            
            // Update each SMA series with the new data
            data.forEach((sma, index) => {
                if (index < smaSeries.length && sma.values && Array.isArray(sma.values)) {
                    try {
                        // Format the data correctly with numeric timestamps
                        const formattedValues = sma.values.map(point => ({
                            time: typeof point.time === 'number' ? point.time : parseInt(point.time),
                            value: parseFloat(point.value)
                        }));
                        
                        console.log(`Setting SMA ${index} data, count:`, formattedValues.length);
                        smaSeries[index].setData(formattedValues);
                    } catch (e) {
                        console.error(`Error setting SMA ${index} data:`, e);
                    }
                }
            });
        });
        
        // DOM chart (using lightweight-charts instead of Highcharts for better performance)
        let domChart = Highcharts.chart('dom-container', {
            chart: {
                type: 'area',
                zooming: {
                    type: 'xy'
                },
                backgroundColor: 'black', // Set background color to black
            },
            title: {
                text: 'Depth of Market',
                style: {
                    color: 'white' // Set title text color to white
                }
            },
            xAxis: {
                minPadding: 0,
                maxPadding: 0,
                title: {
                    text: 'Price',
                    style: {
                        color: 'white' // Set x-axis title text color
                    }
                },
                labels: {
                    style: {
                        color: 'white' // Set x-axis label text color
                    }
                },
                plotLines: [{
                    color: 'white',
                    value: 102, // Initial actual price
                    width: 1,
                    id: 'actualPriceLine', // Add an ID to the plot line for dynamic updates
                    label: {
                        text: 'Actual price',
                        rotation: 90,
                        style: {
                            color: 'white'
                        }
                    }
                }],
            },
            yAxis: [{
                lineWidth: 1,
                gridLineWidth: 1,
                title: null,
                tickWidth: 1,
                tickLength: 5,
                tickPosition: 'inside',
                labels: {
                    align: 'left',
                    x: 8
                }
            }, {
                opposite: true,
                linkedTo: 0,
                lineWidth: 1,
                gridLineWidth: 0,
                title: null,
                tickWidth: 1,
                tickLength: 5,
                tickPosition: 'inside',
                labels: {
                    align: 'right',
                    x: -8,
                    style: {
                        color: 'white' // Set y-axis label text color
                    }
                }
            }],
            legend: {
                enabled: false
            },
            plotOptions: {
                area: {
                    fillOpacity: 0.2,
                    lineWidth: 1,
                    step: 'center'
                }
            },
            tooltip: {
                backgroundColor: 'gray', // Set tooltip background to gray
                headerFormat: '<span style="font-size=10px; color:white;">Price: {point.key}</span><br/>',
                valueDecimals: 2,
                style: {
                    color: 'white' // Set tooltip text color to white
                }
            },
            series: [{
                name: 'Bids',
                data: [],
                color: '#03a7a8'
            }, {
                name: 'Asks',
                data: [],
                color: '#fc5857'
            }]
        });

        // DOM chart (using lightweight-charts instead of Highcharts for better performance)
        let lastDOMUpdate = 0;
        const DOM_THROTTLE_MS = 200; // Only update DOM chart every 200ms
        
        socket.on('depth_of_market', (domData) => {
            const now = performance.now();
            // Throttle updates to reduce browser load
            if (now - lastDOMUpdate < DOM_THROTTLE_MS) {
                return;
            }
            lastDOMUpdate = now;
            
            if (domData && domData.bids && domData.asks) {
                // Sort bids in ascending order by price (X-axis)
                const sortedBids = domData.bids.sort((a, b) => a[0] - b[0]);

                // Sort asks in ascending order by price (X-axis)
                const sortedAsks = domData.asks.sort((a, b) => a[0] - b[0]);

                // Update bids and asks on the chart
                domChart.series[0].setData(sortedBids, true); // Update bids
                domChart.series[1].setData(sortedAsks, true); // Update asks

                // Extract the actual price from domData
                const actualPrice = domData.actualPrice || getMidPrice(sortedBids, sortedAsks);

                // Update the actual price plot line dynamically
                if (actualPrice !== undefined) {
                    domChart.xAxis[0].update({
                        plotLines: [{
                            id: 'actualPriceLine', // Match the ID of the existing plot line
                            color: 'white',
                            value: actualPrice, // Set the new price dynamically
                            width: 1,
                            label: {
                                text: `Actual price: ${actualPrice.toFixed(2)}`,
                                rotation: 90,
                                style: {
                                    color: 'white'
                                }
                            }
                        }]
                    });
                }
            }
        });

        // Helper function to calculate the mid-price (if not provided in domData)
        function getMidPrice(bids, asks) {
            if (bids.length > 0 && asks.length > 0) {
                const bestBid = bids[bids.length - 1][0]; // Last bid price
                const bestAsk = asks[0][0]; // First ask price
                return (bestBid + bestAsk) / 2; // Calculate the mid-price
            }
            return undefined;
        }

        // Loading status handler
        socket.on('loading_status', function(data) {
            console.log('Loading status:', data);
            const loadingContainer = document.getElementById('loading-container');
            const loadingProgressBar = document.getElementById('loading-progress-bar');
            const loadingMessage = document.getElementById('loading-message');
            const loadingPercentage = document.getElementById('loading-percentage');
            const loadingMBInfo = document.getElementById('loading-mb-info');
            const loadingRowInfo = document.getElementById('loading-row-info');
            
            // Show loading container
            loadingContainer.style.display = 'flex';
            
            // Update progress bar
            if (data.progress !== undefined) {
                loadingProgressBar.style.width = `${data.progress}%`;
                loadingPercentage.textContent = `${Math.round(data.progress)}%`;
            }
            
            // Update message
            if (data.message) {
                loadingMessage.textContent = data.message;
                
                // Extract and display megabytes loaded if available
                const mbMatch = data.message.match(/(\d+(?:\.\d+)?) MB/i);
                if (mbMatch && mbMatch.length >= 2) {
                    loadingMBInfo.textContent = `Data loaded: ${mbMatch[1]} MB`;
                    loadingMBInfo.style.display = 'block';
                } else if (data.bytes_loaded) {
                    // If server provides bytes directly
                    const mbLoaded = (data.bytes_loaded / (1024 * 1024)).toFixed(2);
                    loadingMBInfo.textContent = `Data loaded: ${mbLoaded} MB`;
                    loadingMBInfo.style.display = 'block';
                }
                
                // Extract and display row counts if available
                const rowMatch = data.message.match(/(\d+(?:,\d+)*) (?:rows|trades)/i);
                if (rowMatch && rowMatch.length >= 2) {
                    loadingRowInfo.textContent = `Rows: ${rowMatch[1]}`;
                    loadingRowInfo.style.display = 'block';
                }
            }
            
            // Handle completion
            if (data.status === 'complete' || (data.progress >= 95 && data.message && data.message.includes("Successfully loaded"))) {
                // Hide after a short delay to ensure the user sees 100%
                setTimeout(() => {
                    loadingContainer.style.display = 'none';
                }, 1500);
            } else if (data.status === 'error') {
                // Change color to red for errors
                loadingProgressBar.style.backgroundColor = '#f44336';
                // Keep error visible longer
                setTimeout(() => {
                    loadingContainer.style.display = 'none';
                }, 5000);
            }
        });

// Replay controls
const playBtn = document.getElementById('play-btn');
const pauseBtn = document.getElementById('pause-btn');
const stopBtn = document.getElementById('stop-btn');
const speedSlider = document.getElementById('speed-slider');
const speedValue = document.getElementById('speed-value');
// Turbo and Max Speed button variables removed
const positionSlider = document.getElementById('position-slider');
const positionValue = document.getElementById('position-value');
const filenameElement = document.getElementById('filename');

// Event listeners
playBtn.addEventListener('click', () => {
    socket.emit('replay_command', { action: 'play' });
});

pauseBtn.addEventListener('click', () => {
    socket.emit('replay_command', { action: 'pause' });
});

stopBtn.addEventListener('click', () => {
    socket.emit('replay_command', { action: 'stop' });
});

// Turbo and Max Speed buttons have been removed

speedSlider.addEventListener('input', () => {
    const speed = parseFloat(speedSlider.value);
    speedValue.textContent = `${speed}x`;
    
    // Send speed command to server
    socket.emit('replay_command', {
        action: 'set_speed',
        speed: speed
    });
});

positionSlider.addEventListener('change', () => {
    const position = parseInt(positionSlider.value);
    socket.emit('replay_command', { action: 'seek', position: position });
});

// Handle replay status updates
socket.on('replay_status', (status) => {
    console.log('Replay status:', status);
    // Update UI
    playBtn.disabled = status.running && !status.paused;
    pauseBtn.disabled = !status.running || status.paused;
    stopBtn.disabled = !status.running;
    
    // If replay is stopped, ensure charts are cleared
    if (status.status === "stopped") {
        console.log("Replay stopped - clearing all charts");
        clearAllCharts();
    }
    
    // Update position slider
    if (status.total > 0) {
        positionSlider.max = status.total;
        positionSlider.value = status.position;
        positionValue.textContent = `${status.position}/${status.total}`;
    }
    
    // Update speed
    speedSlider.value = status.speed;
    speedValue.textContent = status.speed.toFixed(1) + 'x';
    
    // Update filename
    if (status.filename) {
        filenameElement.textContent = status.filename;
    }
});

// Position updates
socket.on('position_update', (data) => {
    console.log('Position update:', data);
    positionSlider.max = data.total;
    positionSlider.value = data.position;
    positionValue.textContent = `${data.position}/${data.total}`;
    
    // If position is 0, clear all charts
    if (data.position === 0) {
        console.log("Position set to 0 - clearing all charts");
        clearAllCharts();
    }
});

// File info updates
socket.on('file_info', (data) => {
    console.log('File info:', data);
    if (data.filename) {
        filenameElement.textContent = data.filename;
    }
    if (data.total_trades) {
        // Update position slider max
        positionSlider.max = data.total_trades;
        positionValue.textContent = `0/${data.total_trades}`;
    }
});

// Speed updates
socket.on('speed_update', (data) => {
    console.log('Speed update:', data);
    speedSlider.value = data.speed;
    speedValue.textContent = `${data.speed}x`;
});
    </script>
</body>
</html>